## 链接指示符`extern "C"` 用法

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于**C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

这个功能主要用在下面的情况：

**1. C++代码调用C语言代码**

**2. 在C++的头文件中使用**

例如`moduleA`、`moduleB`两个模块，其中A是用C语言实现的，而B是利用C++实现的，在B调用A中的代码:

```c++
#ifndef __MODULEB_H 	//防止该头文件被重复引用
#define __MODULEB_H

#ifdef __cplusplus		//__cplusplus是cpp文件的自定义宏
extern "C"{				//下列diamagnetic编译器会按照C语言的格式进行编译
#endif
	#include "modulea.h"
#ifdef __cplusplus
}
#endif
#endif /*end of __MODULEB_H*/
```

如果模块B要引用模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但并不会报错；它会在**链接阶段**从模块A编译生成的目标代码中找到该函数。

extern是C/C++语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。

**extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。**

**extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。**

extern ”C“的使用要点

1.  单一语句形式的链接指示符

   ```c++
   extern "C" double sqrt(double);
   ```

2. 可以是复合语句, 相当于复合语句中的声明都加了extern "C"

   ```c++
   extern "C"
   {
         double sqrt(double);
         int min(int, int);
   }
   ```

3. 可以包含头文件，相当于头文件中的声明都加了extern "C"
4. 不可以将extern "C" 添加在函数内部

## C++中的存储类型

C++在内存上有四种存储区：

##### 1. 全局区/静态区

通常存储**全局变量、静态数据和常量（可读可写）。**

1. `.BSS`段：初始化为0的全局变量和静态变量（也就是未显式初始化，该情况下变量的值默认为0，例如`static int val;`。
2. `.DATA`段：未初始化为0的全局变量的静态变量，例如`static int val = 3;`

##### 2. 代码区（.text段)

所有类成员函数和非成员函数代码。ROM，只读，存放函数体的二进制代码。

##### 3. 栈区（stack区）

在执行函数时分配的局部变量、函数参数、返回类型和返回地址等都是在栈区上创建的。

##### 4. 堆区（heap区）

从堆上分配的内存实在程序运行时由程序员申请的内存，在程序结束时由程序员负责释放。

有些资料会认为还有一个文字常量区：存储字面量、常量字符串等，类似于`.rodata`区。

![c++内存类型](C:\Users\yanghexing\Desktop\算法\pic\c++内存类型.png)

## 指针的作用

在C++中指针的主要用处是**管理和操纵动态分配的内存。**

静态与动态内存分配的两个主要区别是：

1. 静态对象是有名字的变量，我们直接对其进行操作；而动态对象是没有名字的变量，但我们通过指针间接地对它进行操作。

2. 静态对象的分配与释放由编译器自动处理。相反动态对象的分配与释放必须由程序员显式地管理。它通过new 和delete 两个表达式来完成，例如：

```c++
int *pint = new int(1024);	//分配了一个迷宫有名字的int类型对象，初始值为1024
int *pia = new int[ 4 ];  	//分配了一个含有整数元素的数组。不行的是我们没有办法给动态分配的数组的每个元素显式的指定一个初始值。
```

**分配动态数组时返回值只是一个指针，与分配单一动态对象的返回类型相同。**

```c++
// 删除单个对象
delete pint;
// 删除一个对象数组
delete [] pia;
```

## `malloc`和`new`的区别

##### 	**1. 申请的内存所在位置**

​		`new`操作符从**自由存储区（free store）**上为对象动态分配内存空间，而**`malloc`函数从堆上动态分配内存**。自由存储区是C++基于`new`操作符的一个抽象概念，凡是通过`new`操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序内存动态分配，c语言实用`malloc`函数从堆上分配内存，使用`free`释放已分配的对应内存。

​		那么*自由存储区是否可以是堆（问题等价于new是否能在堆上动态分配内存）？*这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

​		特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：

```c++
new (place_address) type
```



## 堆和栈的区别

## 常量指针和指针常量的区别

**左定值，右定向**，请看下面的示例：

```c++
const int *p1 = 0;
const int num = 10;	//常量对象必须在声明的时候进行初始化。
p1 = &num;

int dval = 20;
p1 = &dval;      //此时不能通过p1修改dval，尽管dval本身是一个变量。

int * const p2 = &dval;
*p2 += 10;      //此时可以通过p2修改dval,但指针指向的位置不可以被修改
```

在实际的程序中，指向`const`的指针常被用过函数的形式参数。它用来保证，**被传递给函数的实际对象在函数中不会被修改**。例如：

```c++
int strcmp（const char *str1,const char *str2);
```

## 虚函数和纯虚函数的作用

## 构造函数和析构函数在类中的调用顺序

## C++中`const`与`#define`的区别

具体分析 `#define` 和`const`的区别：

```c++
const float PI = 3.14;
#define PI 3.14
```

1. **类型的安全性检查：**`const`常量有数据类型，而`define`定义的宏常量没有数据类型，因此编译器可以对前者进行类型安全检查，而只对后者进行字符替换，在进行字符替换时有可能会产生意料之外的错误，如下列的程序所示。

2. **调试：**部分调试工具可以对`const`常量进行调试，但不能对宏常量进行调试。

3. **编译器处理方式不同：**`define`宏是在预处理阶段展开，`const`常量则是在编译运行阶段使用。

4. **存储方式不同：**`define`宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，`const`分配内存。）例如：

   ```c++
   #define PI 3.14159 //常量宏  
   const doulbe Pi=3.14159; //此时并未将Pi放入ROM中 ......  
   double i=Pi; //此时为Pi分配内存，以后不再分配！  
   double j=Pi; //没有内存分配  
   double I=PI; //编译期间进行宏替换，分配内存  
   double J=PI; //再进行宏替换，又一次分配内存！
   ```

   `const`定义常量从**汇编的角度**来看，只是给出了对应的内存地址，而不是象`#define`一样给出的是立即数，所以，`const`定义的常量在程序**运行过程**中只有一份拷贝（**因为是全局的只读变量，存在静态区**），而 `#define`定义的常量在**内存**中有若干个拷贝。

5. **效率：**编译器通常不为普通`const`常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

接下来看一个典型程序：

```c++
#include <iostream>
using namespace std;

int main(){
    int num = 1;
    
    #define t1 num+num
    #define t2 t1%t1
    cout<<"t2 is "<<t2<<endl;	//t2 is 2
    
    const int s1 = num + num;
    const int s2 = s1%s1;
    cout<<"s2 is "<<s2<<endl;	//s2 is 0
    
    return 0;
}

```

运行结果如注释所示，分别得到 `t2 is 2` 和 `s2 is 0`

分析原因：`const` 定义常量`s1`和`s2`，`s1`的值是`num+num = 2`，`s2`的值是`s1%s1`，所以最终的结果是`s2 is 0`；而 `define` 定义的变量做替换后，C++把`cout<<"t2 is "<<t2<<endl;`语句编译成了：`cout<<"t2 is "<<num+num%num+num<<endl;`，所以最终的结果是 `t2 is 2` 。

##### **类中的常量**

有时我们希望某些常量只在类中有效。由于#define定义的宏常量是全局的，因此并不能达到目的。**`const`数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其`const`数据成员的值可以不同。**

**不能在类声明中初始化`const`数据成员。**以下用法是错误的，因为类的对象未被创建时，编译器不知道SIZE的值是什么：

```c++
class A
{
    const int SIZE = 100;  // 错误，企图在类声明中初始化const数据成员
    int array[SIZE];       // 错误，未知的SIZE
};
```

**`const`数据成员的初始化只能在类构造函数的初始化表中进行，**例如：

```c++
class A
{
	A(int size):SIZE(size){};	//构造函数的初始化表
    const int SIZE ;  
};
//A::A(int size) : SIZE(size){}	//构造函数的初始化表
A  a(100);  // 对象 a 的SIZE值为100
A  b(200);  // 对象 b 的SIZE值为200
```

**怎样才能建立在整个类中都恒定的常量呢？**别指望`const`数据成员了，应该用类中的**枚举常量**来实现。例如:

```C++
class A
{
	enum { SIZE1 = 100, SIZE2 = 200}; //枚举常量 sizeof(em) = 4；
    int array1[SIZE1];
    int array2[SIZE2];
}
```

**枚举常量不会占用对象的存储空间，它们在编译时被全部求值。枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点数（如PI=3.14159）。`sizeof(A) = 1200`。**

